{% extends "base.html" %} {% block title %}Train Gesture - Gesture Auth{%
endblock %} {% block canvas_color %}#0d6efd{% endblock %} {% block content %}
<section class="py-5">
    <div class="container px-5">
        <div class="row justify-content-center">
            <div class="col-lg-8">
                <div class="text-center mb-4">
                    <h1 class="fw-bolder mb-3">Train Your Gesture</h1>
                    <div class="card border-primary mb-3">
                        <div class="card-body">
                            <h6 class="card-title">
                                <i class="bi bi-lightbulb me-2"></i>Tips for
                                success:
                            </h6>
                            <ul class="mb-0">
                                <li>Choose a simple gesture</li>
                                <li>Do not draw too quickly</li>
                                <li>
                                    Use the <i>Clear</i> button if you make a
                                    mistake
                                </li>
                            </ul>
                        </div>
                    </div>
                    <p class="lead text-muted mb-2">
                        Click to start, move to draw
                    </p>
                    <p class="text-muted mb-0">
                        Training session <span id="sessionCount">1</span> of
                        <span id="totalSessions">15</span>
                    </p>
                </div>

                <div class="card shadow border-0">
                    <div class="card-body p-5">
                        <div class="gesture-progress mb-4">
                            <div
                                id="progressBar"
                                class="gesture-progress-bar progress-too-small"
                                style="width: 0%"
                            >
                                <span id="progressText">0 / 60 samples</span>
                            </div>
                        </div>

                        <div class="text-center mb-4">
                            <div class="canvas-container">
                                <canvas
                                    id="gestureCanvas"
                                    width="500"
                                    height="500"
                                ></canvas>
                            </div>
                        </div>

                        <div
                            class="d-grid gap-2 d-md-flex justify-content-md-center mb-3"
                        >
                            <button
                                class="btn btn-primary btn-lg px-4"
                                id="submitBtn"
                                disabled
                            >
                                <i class="bi bi-check-circle me-2"></i>Submit
                                Gesture
                            </button>
                            <button
                                class="btn btn-outline-secondary btn-lg px-4"
                                id="clearBtn"
                            >
                                <i class="bi bi-arrow-clockwise me-2"></i>Clear
                            </button>
                            <button
                                class="btn btn-success btn-lg px-4"
                                id="completeBtn"
                                disabled
                                style="display: none"
                            >
                                <i class="bi bi-check-circle-fill me-2"></i
                                >Complete Training
                            </button>
                        </div>

                        <div class="status-message">
                            <div id="statusMessage"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>
{% endblock %} {% block scripts %}
<script>
    // Configuration will be loaded from server
    let CONFIG = null;

    // Fetch configuration from backend
    async function loadConfig() {
        try {
            const response = await fetch("/api/config");
            CONFIG = await response.json();
            console.log("Loaded config:", CONFIG);

            // Update UI with loaded config
            totalSessions.textContent = CONFIG.TRAINING_ITERATIONS;
            progressText.textContent = "0 / " + CONFIG.SAMPLES + " samples";

            // Initialize WebSocket after config is loaded
            initWebSocket();
        } catch (error) {
            console.error("Failed to load config:", error);
            // Fallback to default values
            CONFIG = {
                CANVAS_SIZE: 500,
                SAMPLE_DISTANCE: 15,
                SAMPLES: 120,
                MIN_PATH_LENGTH: 500,
                MAX_PATH_LENGTH: 2000,
                TRAINING_ITERATIONS: 15,
            };
            totalSessions.textContent = CONFIG.TRAINING_ITERATIONS;
            initWebSocket();
        }
    }

    const canvas = document.getElementById("gestureCanvas");
    const ctx = canvas.getContext("2d");
    const submitBtn = document.getElementById("submitBtn");
    const clearBtn = document.getElementById("clearBtn");
    const completeBtn = document.getElementById("completeBtn");
    const statusMessage = document.getElementById("statusMessage");
    const progressBar = document.getElementById("progressBar");
    const progressText = document.getElementById("progressText");
    const sessionCount = document.getElementById("sessionCount");
    const totalSessions = document.getElementById("totalSessions");

    let ws = null;
    let currentIteration = 1;
    let completedIterations = 0;
    let isDrawing = false;
    let drawingStarted = false;
    let drawingComplete = false;
    let gestureData = [];
    let lastMeasuredPoint = null;
    let totalDistance = 0;
    let totalPathLength = 0;
    let lastDrawPoint = null;
    let maxSamplesReached = false;
    let maxPathReached = false;

    ctx.lineWidth = 3;
    ctx.lineCap = "round";
    ctx.strokeStyle = "#0d6efd";

    // Initialize WebSocket
    function initWebSocket() {
        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${protocol}//${window.location.host}/ws/train`;

        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
            console.log("WebSocket connected");
        };

        ws.onmessage = (event) => {
            const response = JSON.parse(event.data);
            handleServerResponse(response);
        };

        ws.onerror = (error) => {
            console.error("WebSocket error:", error);
            statusMessage.innerHTML =
                '<div class="alert alert-danger"><i class="bi bi-exclamation-circle me-2"></i>Connection error. Please refresh the page.</div>';
        };

        ws.onclose = () => {
            console.log("WebSocket disconnected");
        };
    }

    function handleServerResponse(response) {
        if (response.training_complete) {
            // Training successful - model saved
            submitBtn.style.display = "none";
            clearBtn.style.display = "none";
            completeBtn.style.display = "inline-block";
            completeBtn.disabled = false;
            statusMessage.innerHTML = `<div class="alert alert-success"><i class="bi bi-check-circle-fill me-2"></i>${response.message}</div>`;
        } else if (response.training_failed) {
            // Training failed - EER too high, need to retry
            submitBtn.style.display = "none";
            clearBtn.style.display = "none";
            statusMessage.innerHTML = `<div class="alert alert-danger"><i class="bi bi-exclamation-triangle me-2"></i>${response.error}</div>`;

            // Add a retry button
            setTimeout(() => {
                statusMessage.innerHTML +=
                    '<div class="mt-3"><button class="btn btn-primary" onclick="location.reload()"><i class="bi bi-arrow-clockwise me-2"></i>Try Again</button></div>';
            }, 100);
        } else if (response.success) {
            completedIterations++;
            statusMessage.innerHTML = `<div class="alert alert-success"><i class="bi bi-check-circle me-2"></i>${response.message} (${completedIterations}/${CONFIG.TRAINING_ITERATIONS})</div>`;

            if (completedIterations >= CONFIG.TRAINING_ITERATIONS) {
                // All iterations received, now analyzing...
                submitBtn.style.display = "none";
                clearBtn.style.display = "none";
                statusMessage.innerHTML =
                    '<div class="alert alert-info"><i class="bi bi-hourglass-split me-2"></i>Analyzing gesture security... Please wait.</div>';
            } else {
                // Move to next iteration
                currentIteration++;
                sessionCount.textContent = currentIteration;
                setTimeout(() => {
                    resetCanvas();
                    statusMessage.innerHTML = `<div class="alert alert-info"><i class="bi bi-info-circle me-2"></i>Session ${currentIteration} of ${CONFIG.TRAINING_ITERATIONS}. Draw your gesture again.</div>`;
                }, 1500);
            }
        } else {
            statusMessage.innerHTML = `<div class="alert alert-danger"><i class="bi bi-exclamation-circle me-2"></i>${response.error}</div>`;
            submitBtn.disabled = false;
        }
    }

    function resetCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        gestureData = [];
        lastMeasuredPoint = null;
        totalDistance = 0;
        totalPathLength = 0;
        lastDrawPoint = null;
        maxSamplesReached = false;
        maxPathReached = false;
        isDrawing = false;
        drawingStarted = false;
        drawingComplete = false;
        progressBar.style.width = "0%";
        progressText.textContent = "0 / " + CONFIG.SAMPLES + " samples";
        progressBar.className = "gesture-progress-bar progress-too-small";
        submitBtn.disabled = true;
    }

    function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top,
            timestamp: Date.now(),
        };
    }

    function getTouchPos(e) {
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        return {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top,
            timestamp: Date.now(),
        };
    }

    function distance(p1, p2) {
        return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
    }

    function finishDrawing() {
        if (!drawingStarted || drawingComplete) return;

        isDrawing = false;
        drawingComplete = true;
        updateProgress();
    }

    function updateProgress() {
        const samples = gestureData.length;
        const percentage = Math.min((samples / CONFIG.SAMPLES) * 100, 100);

        progressBar.style.width = percentage + "%";
        progressText.textContent =
            samples + " / " + CONFIG.SAMPLES + " samples";

        const validSamples = samples === CONFIG.SAMPLES;
        const validPathLength =
            totalPathLength >= CONFIG.MIN_PATH_LENGTH &&
            totalPathLength <= CONFIG.MAX_PATH_LENGTH;

        if (
            samples < CONFIG.SAMPLES ||
            totalPathLength < CONFIG.MIN_PATH_LENGTH
        ) {
            progressBar.className = "gesture-progress-bar progress-too-small";
            submitBtn.disabled = true;

            if (!drawingComplete) {
                if (samples < CONFIG.SAMPLES) {
                    statusMessage.innerHTML =
                        '<div class="alert alert-warning"><i class="bi bi-exclamation-triangle me-2"></i>Keep drawing! Need ' +
                        (CONFIG.SAMPLES - samples) +
                        " more samples.</div>";
                } else {
                    const neededLength = Math.ceil(
                        CONFIG.MIN_PATH_LENGTH - totalPathLength,
                    );
                    statusMessage.innerHTML =
                        '<div class="alert alert-warning"><i class="bi bi-exclamation-triangle me-2"></i>Keep drawing! Need ' +
                        neededLength +
                        " more pixels.</div>";
                }
            } else {
                statusMessage.innerHTML =
                    '<div class="alert alert-danger"><i class="bi bi-x-circle me-2"></i>Gesture too short. Clear and draw a longer gesture.</div>';
            }
        } else if (validSamples && validPathLength) {
            progressBar.className = "gesture-progress-bar progress-ideal";
            submitBtn.disabled = false;
            if (drawingComplete) {
                statusMessage.innerHTML =
                    '<div class="alert alert-success"><i class="bi bi-check-circle me-2"></i>Perfect! Ready to submit!</div>';
            } else {
                statusMessage.innerHTML =
                    '<div class="alert alert-info"><i class="bi bi-info-circle me-2"></i>Looking good! Click to finish.</div>';
            }
        } else if (
            samples >= CONFIG.SAMPLES ||
            totalPathLength >= CONFIG.MAX_PATH_LENGTH
        ) {
            progressBar.className = "gesture-progress-bar progress-ideal";
            submitBtn.disabled = false;
            statusMessage.innerHTML =
                '<div class="alert alert-success"><i class="bi bi-check-circle me-2"></i>Maximum reached! Ready to submit!</div>';
        }
    }

    function addMeasurement(pos) {
        if (maxSamplesReached) return;

        if (!lastMeasuredPoint) {
            lastMeasuredPoint = pos;
            gestureData.push(pos);
            updateProgress();
            return;
        }

        const dist = distance(lastMeasuredPoint, pos);
        totalDistance += dist;

        if (totalDistance >= CONFIG.SAMPLE_DISTANCE) {
            if (gestureData.length < CONFIG.SAMPLES) {
                gestureData.push(pos);
                lastMeasuredPoint = pos;
                totalDistance = 0;
                updateProgress();
            } else {
                maxSamplesReached = true;
                updateProgress();
            }
        }
    }

    canvas.addEventListener("click", (e) => {
        if (e.button === 2) return;
        if (drawingComplete) return;

        if (!drawingStarted) {
            isDrawing = true;
            drawingStarted = true;

            const pos = getMousePos(e);
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            lastMeasuredPoint = null;
            totalDistance = 0;
            lastDrawPoint = pos;
            addMeasurement(pos);
        } else if (isDrawing) {
            finishDrawing();
        }
    });

    canvas.addEventListener("mousemove", (e) => {
        if (!isDrawing) return;

        const pos = getMousePos(e);

        if (lastDrawPoint) {
            const segmentDist = distance(lastDrawPoint, pos);

            if (totalPathLength + segmentDist > CONFIG.MAX_PATH_LENGTH) {
                maxPathReached = true;
                finishDrawing();
                return;
            }

            totalPathLength += segmentDist;
            lastDrawPoint = pos;
        }

        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        addMeasurement(pos);

        if (maxSamplesReached) {
            finishDrawing();
        }
    });

    let touchStartTime = 0;
    canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        touchStartTime = Date.now();

        if (drawingComplete) return;

        if (!drawingStarted) {
            isDrawing = true;
            drawingStarted = true;

            const pos = getTouchPos(e);
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            lastMeasuredPoint = null;
            totalDistance = 0;
            lastDrawPoint = pos;
            addMeasurement(pos);
        }
    });

    canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();
        if (!isDrawing) return;

        const pos = getTouchPos(e);

        if (lastDrawPoint) {
            const segmentDist = distance(lastDrawPoint, pos);

            if (totalPathLength + segmentDist > CONFIG.MAX_PATH_LENGTH) {
                maxPathReached = true;
                finishDrawing();
                return;
            }

            totalPathLength += segmentDist;
            lastDrawPoint = pos;
        }

        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        addMeasurement(pos);

        if (maxSamplesReached) {
            finishDrawing();
        }
    });

    canvas.addEventListener("touchend", (e) => {
        e.preventDefault();
        const touchDuration = Date.now() - touchStartTime;

        if (touchDuration < 200 && isDrawing && drawingStarted) {
            finishDrawing();
        }
    });

    clearBtn.addEventListener("click", () => {
        resetCanvas();
        statusMessage.innerHTML = "";
    });

    submitBtn.addEventListener("click", () => {
        if (
            gestureData.length !== CONFIG.SAMPLES ||
            totalPathLength < CONFIG.MIN_PATH_LENGTH ||
            totalPathLength > CONFIG.MAX_PATH_LENGTH
        ) {
            return;
        }

        statusMessage.innerHTML =
            '<div class="alert alert-info"><i class="bi bi-hourglass-split me-2"></i>Sending gesture...</div>';
        submitBtn.disabled = true;

        // Send via WebSocket
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(
                JSON.stringify({
                    iteration: currentIteration,
                    gesture: gestureData,
                    pathLength: totalPathLength,
                }),
            );
        } else {
            statusMessage.innerHTML =
                '<div class="alert alert-danger"><i class="bi bi-exclamation-circle me-2"></i>Connection lost. Please refresh the page.</div>';
            submitBtn.disabled = false;
        }
    });

    completeBtn.addEventListener("click", () => {
        window.location.href = '{{ url_for("verify_page") }}';
    });

    // Load configuration and initialize WebSocket on page load
    loadConfig();
</script>
{% endblock %}
